module Wool
  class Scanner
    class Context < Struct.new(:type, :data)
      def initialize(*args)
        super
        self.data ||= {}
      end
    end

    attr_accessor :settings
    attr_accessor :context_stack
    attr_accessor :indent_stack

    DEFAULT_SETTINGS = {:fix => false, :output => STDOUT,
                        :__using__ => Wool::Warning.all_warnings,
                        :__fix__ => Wool::Warning.all_warnings}

    # Initializes the scanner with the given settings
    #
    # @param [Hash] settings the settings to use to customize this scanner's
    #   scanning behavior
    def initialize(settings = DEFAULT_SETTINGS)
      @settings = DEFAULT_SETTINGS.merge(settings)
      self.context_stack = []
      self.indent_stack = []
    end

    # Returns the list of warnings to use for scanning.
    def using
      @settings[:__using__]
    end

    # Should we use this warning?
    def using?(warning)
      @settings[:__using__].include? warning
    end

    # Returns the list of warnings to use for scanning.
    def fix
      @settings[:__fix__]
    end

    # Should we use this warning?
    def fixing?(warning)
      @settings[:__fix__].include? warning.class
    end

    # Scans the text for warnings.
    #
    # @param [String] text the input ruby file to scan
    # @return [Array[Wool::Warnings]] the warnings generated by the code.
    #   If the code is clean, an empty array is returned.
    def scan(text, filename='(none)')
      warnings = scan_for_file_warnings(text, filename)
      text = filter_fixable(warnings).inject(text) do |text, warning|
        warning.fix(text)
      end
      with_fixing_piped_to_output do
        text.split(/\n/).each_with_index do |line, number|
          warnings.concat process_line(line, number + 1, filename)
        end
      end
      warnings
    end

    def with_fixing_piped_to_output
      self.settings[:output_lines] = []
      yield
      if @settings[:fix]
        self.settings[:output_file].write self.settings[:output_lines].join("\n")
      end
    end

    def process_line(line, line_number, filename)
      update_context! line
      warnings = all_warnings_for_line(line, line_number, filename)
      fix_input(warnings, line, line_number, filename) if @settings[:fix]
      warnings
    end

    def fix_input(warnings, line, line_number, filename)
      fixable_warnings = filter_fixable warnings
      if fixable_warnings.size == 1
        self.settings[:output_lines] << fixable_warnings.first.fix(self.context_stack) rescue line
      elsif fixable_warnings.size > 1
        new_text = fixable_warnings.first.fix(self.context_stack) rescue line
        process_line(new_text, line_number, filename)
      else
        self.settings[:output_lines] << line
      end
    end

    def all_warnings_for_line(line, line_number, filename)
      new_warnings = check_for_indent_warnings!(line, filename)
      new_warnings.concat scan_for_line_warnings(line, filename)
      new_warnings.each {|warning| warning.line_number = line_number}
    end

    def filter_fixable(warnings)
      warnings.select {|warning| warning.fixable? && fixing?(warning) }
    end

    # Checks for new warnings based on indentation.
    def check_for_indent_warnings!(line, filename)
      return [] if line == ""
      indent_size = get_indent_size line
      if indent_size > current_indent
        self.indent_stack.push indent_size
      elsif indent_size < current_indent
        previous = self.indent_stack.pop
        if indent_size != current_indent &&
           using.include?(MisalignedUnindentationWarning)
        return [MisalignedUnindentationWarning.new(filename, line, current_indent)]
        end
      end
      []
    end

    # Gets the current indent size
    def current_indent
      self.indent_stack.last || 0
    end

    # Gets the indent size of a given line
    def get_indent_size(line)
      line.match(/^\s*/)[0].size
    end

    # Updates the context of the scanner right now based on poor heuristics.
    def update_context!(line)
      case line
      when /^\s*class\s+([A-Z][A-Za-z0-9_]*)/
        self.context_stack.push(Context.new(:class, {:class_name => $1}))
      when /^\s*module\s+([A-Z][A-Za-z0-9_]*)/
        self.context_stack.push(Context.new(:module, {:module_name => $1}))
      when /^\s*if([^$]*?)(then)?\s*$/
        self.context_stack.push(Context.new(:if, {:condition => $1.strip}))
      when /^\s*end\b/
        self.context_stack.pop
      end
    end

    # Goes through all file warning subclasses and see what warnings the file
    # generates as a whole.
    def scan_for_file_warnings(file, filename)
      scan_for_warnings(using & FileWarning.all_warnings, file, filename)
    end

    # Goes through all line warning subclasses and checks if we got some new
    # warnings for a given line
    def scan_for_line_warnings(line, filename)
      scan_for_warnings(using & LineWarning.all_warnings, line, filename)
    end

    private

    def scan_for_warnings(warnings, content, filename)
      warnings.inject([]) do |acc, warning|
        if warning.match?(content, self.context_stack, @settings)
          acc << warning.new(filename, content)
        end
        acc
      end
    end
  end
end